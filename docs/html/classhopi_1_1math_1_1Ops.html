<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Homing Pigeon: hopi::math::Ops Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="hopi-logo-small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Homing Pigeon
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>hopi</b></li><li class="navelem"><b>math</b></li><li class="navelem"><a class="el" href="classhopi_1_1math_1_1Ops.html">Ops</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classhopi_1_1math_1_1Ops-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hopi::math::Ops Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Ops_8h_source.html">Ops.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0707e6965c26c85efc73a18cf111decd"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#a0707e6965c26c85efc73a18cf111decd">kl</a> (<a class="el" href="classhopi_1_1distributions_1_1Distribution.html">distributions::Distribution</a> *d1, <a class="el" href="classhopi_1_1distributions_1_1Distribution.html">distributions::Distribution</a> *d2)</td></tr>
<tr class="separator:a0707e6965c26c85efc73a18cf111decd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1176e0614fe6fcc326660f80afd8696"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#ad1176e0614fe6fcc326660f80afd8696">kl_categorical</a> (<a class="el" href="classhopi_1_1distributions_1_1Distribution.html">distributions::Distribution</a> *d1, <a class="el" href="classhopi_1_1distributions_1_1Distribution.html">distributions::Distribution</a> *d2)</td></tr>
<tr class="separator:ad1176e0614fe6fcc326660f80afd8696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae019d2fac8cc6e992ebcbbffffa47bb8"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#ae019d2fac8cc6e992ebcbbffffa47bb8">kl_dirichlet</a> (<a class="el" href="classhopi_1_1distributions_1_1Distribution.html">distributions::Distribution</a> *d1, <a class="el" href="classhopi_1_1distributions_1_1Distribution.html">distributions::Distribution</a> *d2)</td></tr>
<tr class="separator:ae019d2fac8cc6e992ebcbbffffa47bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a7f3c9681a472475c4d21a5d2b9042"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#ab8a7f3c9681a472475c4d21a5d2b9042">log_beta</a> (const torch::Tensor &amp;x)</td></tr>
<tr class="separator:ab8a7f3c9681a472475c4d21a5d2b9042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf457dad0a02e96a0efe2f1ce924fc6f"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#acf457dad0a02e96a0efe2f1ce924fc6f">log_gamma</a> (double x)</td></tr>
<tr class="separator:acf457dad0a02e96a0efe2f1ce924fc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2384b690d89436f24b97c6005aa61e4e"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#a2384b690d89436f24b97c6005aa61e4e">beta</a> (const torch::Tensor &amp;x)</td></tr>
<tr class="separator:a2384b690d89436f24b97c6005aa61e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d73e345255e3d63ca0c90ee797de1c9"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#a7d73e345255e3d63ca0c90ee797de1c9">digamma</a> (double x)</td></tr>
<tr class="separator:a7d73e345255e3d63ca0c90ee797de1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0923f77839f6fadb4d7895a34d273de7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#a0923f77839f6fadb4d7895a34d273de7">randomInt</a> (const torch::Tensor &amp;weights)</td></tr>
<tr class="separator:a0923f77839f6fadb4d7895a34d273de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ded19f4540bc43d595c650c99f416b"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#a54ded19f4540bc43d595c650c99f416b">randomInt</a> (int max)</td></tr>
<tr class="separator:a54ded19f4540bc43d595c650c99f416b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d2f9cd2ca79e693c691e610d99be4e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#ad6d2f9cd2ca79e693c691e610d99be4e">randomInt</a> (const std::vector&lt; double &gt; &amp;weights)</td></tr>
<tr class="separator:ad6d2f9cd2ca79e693c691e610d99be4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5855f2d59338b8b84581cff7be312ac"><td class="memItemLeft" align="right" valign="top">static torch::Tensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#ae5855f2d59338b8b84581cff7be312ac">one_hot</a> (int size, int index)</td></tr>
<tr class="separator:ae5855f2d59338b8b84581cff7be312ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800d365ad2c44f7d382e0eaac193a340"><td class="memItemLeft" align="right" valign="top">static torch::Tensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#a800d365ad2c44f7d382e0eaac193a340">uniform</a> (const torch::IntArrayRef &amp;sizes, int dim=0)</td></tr>
<tr class="separator:a800d365ad2c44f7d382e0eaac193a340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a085233112e587f7bb3e3d847480d8e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#a1a085233112e587f7bb3e3d847480d8e">unsqueeze</a> (long n, std::initializer_list&lt; torch::Tensor * &gt; tensors)</td></tr>
<tr class="separator:a1a085233112e587f7bb3e3d847480d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b5a8632a27ecac7fb9104ee63292f1"><td class="memItemLeft" align="right" valign="top">static torch::Tensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#ae6b5a8632a27ecac7fb9104ee63292f1">expansion</a> (const torch::Tensor &amp;x1, long n, long dim)</td></tr>
<tr class="separator:ae6b5a8632a27ecac7fb9104ee63292f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173ec1c26a57825cd6e62e78454a6a34"><td class="memItemLeft" align="right" valign="top">static torch::Tensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#a173ec1c26a57825cd6e62e78454a6a34">multiplication</a> (const torch::Tensor &amp;x1, const torch::Tensor &amp;x2, std::initializer_list&lt; int &gt; ml)</td></tr>
<tr class="separator:a173ec1c26a57825cd6e62e78454a6a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6866343eeeac2ad44cd39612d32d3c34"><td class="memItemLeft" align="right" valign="top">static torch::Tensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#a6866343eeeac2ad44cd39612d32d3c34">average</a> (const torch::Tensor &amp;x1, const torch::Tensor &amp;x2, std::initializer_list&lt; int &gt; ml, std::initializer_list&lt; int &gt; el={})</td></tr>
<tr class="separator:a6866343eeeac2ad44cd39612d32d3c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3deee995268f1826fb72963a7a57369"><td class="memItemLeft" align="right" valign="top">static torch::Tensor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhopi_1_1math_1_1Ops.html#ad3deee995268f1826fb72963a7a57369">outer_tensor_product</a> (std::initializer_list&lt; torch::Tensor * &gt; ts)</td></tr>
<tr class="separator:ad3deee995268f1826fb72963a7a57369"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class contains mathematical functions and operators used throughout the framework. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6866343eeeac2ad44cd39612d32d3c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6866343eeeac2ad44cd39612d32d3c34">&#9670;&nbsp;</a></span>average()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor hopi::math::Ops::average </td>
          <td>(</td>
          <td class="paramtype">const torch::Tensor &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const torch::Tensor &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; int &gt;&#160;</td>
          <td class="paramname"><em>ml</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; int &gt;&#160;</td>
          <td class="paramname"><em>el</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the weighted average of "x1" along the dimension specified by the matching list, and the weights of the average are the elements of "x2".</p>
<p>Details: The average operator first perform a element-wise multiplication by matching the dimensions of "x2" to the dimensions of "x1" using the matching list "ml". Then, it performs a summation over the dimensions of "x2" that does not belong to the exclusion list "el".</p>
<p>More details can be found in the paper named: "The compelling free energy: A novel perspective on active inference".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>the first tensor </td></tr>
    <tr><td class="paramname">x2</td><td>the second tensor </td></tr>
    <tr><td class="paramname">ml</td><td>the matching list </td></tr>
    <tr><td class="paramname">el</td><td>the exclusion list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the average of "x1" with respect to "x2" according to the matching and exclusion list </dd></dl>

</div>
</div>
<a id="a2384b690d89436f24b97c6005aa61e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2384b690d89436f24b97c6005aa61e4e">&#9670;&nbsp;</a></span>beta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hopi::math::Ops::beta </td>
          <td>(</td>
          <td class="paramtype">const torch::Tensor &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the beta function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the function's inputs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the beta function of x </dd></dl>

</div>
</div>
<a id="a7d73e345255e3d63ca0c90ee797de1c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d73e345255e3d63ca0c90ee797de1c9">&#9670;&nbsp;</a></span>digamma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hopi::math::Ops::digamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the digamma function of x </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the digamma function of x </dd></dl>

</div>
</div>
<a id="ae6b5a8632a27ecac7fb9104ee63292f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b5a8632a27ecac7fb9104ee63292f1">&#9670;&nbsp;</a></span>expansion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor hopi::math::Ops::expansion </td>
          <td>(</td>
          <td class="paramtype">const torch::Tensor &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs an expansion of the tensor "x1", this expansion will lead to a new dimension of size "n" inserted after the dimension "dim". More information about the expansion operator can be found in the paper named: "The compelling free energy: A novel perspective on active inference". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>the tensor to be expanded </td></tr>
    <tr><td class="paramname">n</td><td>the size of the new dimension </td></tr>
    <tr><td class="paramname">dim</td><td>the dimension after which the expansion should be performed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the expended tensor </dd></dl>

</div>
</div>
<a id="a0707e6965c26c85efc73a18cf111decd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0707e6965c26c85efc73a18cf111decd">&#9670;&nbsp;</a></span>kl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hopi::math::Ops::kl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhopi_1_1distributions_1_1Distribution.html">distributions::Distribution</a> *&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhopi_1_1distributions_1_1Distribution.html">distributions::Distribution</a> *&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Kullback-Leibler (KL) divergence between the two distributions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d1</td><td>first distribution </td></tr>
    <tr><td class="paramname">d2</td><td>second distribution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the kL divergence </dd></dl>

</div>
</div>
<a id="ad1176e0614fe6fcc326660f80afd8696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1176e0614fe6fcc326660f80afd8696">&#9670;&nbsp;</a></span>kl_categorical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hopi::math::Ops::kl_categorical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhopi_1_1distributions_1_1Distribution.html">distributions::Distribution</a> *&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhopi_1_1distributions_1_1Distribution.html">distributions::Distribution</a> *&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Kullback-Leibler (KL) divergence between the two categorical distributions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d1</td><td>first categorical distribution </td></tr>
    <tr><td class="paramname">d2</td><td>second categorical distribution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the kL divergence </dd></dl>

</div>
</div>
<a id="ae019d2fac8cc6e992ebcbbffffa47bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae019d2fac8cc6e992ebcbbffffa47bb8">&#9670;&nbsp;</a></span>kl_dirichlet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hopi::math::Ops::kl_dirichlet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhopi_1_1distributions_1_1Distribution.html">distributions::Distribution</a> *&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhopi_1_1distributions_1_1Distribution.html">distributions::Distribution</a> *&#160;</td>
          <td class="paramname"><em>d2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the Kullback-Leibler (KL) divergence between the two Dirichlet distributions </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d1</td><td>first Dirichlet distribution </td></tr>
    <tr><td class="paramname">d2</td><td>second Dirichlet distribution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the kL divergence </dd></dl>

</div>
</div>
<a id="ab8a7f3c9681a472475c4d21a5d2b9042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a7f3c9681a472475c4d21a5d2b9042">&#9670;&nbsp;</a></span>log_beta()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hopi::math::Ops::log_beta </td>
          <td>(</td>
          <td class="paramtype">const torch::Tensor &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the logarithm of the generalised beta function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the function's inputs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logarithm of the generalised beta function of x </dd></dl>

</div>
</div>
<a id="acf457dad0a02e96a0efe2f1ce924fc6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf457dad0a02e96a0efe2f1ce924fc6f">&#9670;&nbsp;</a></span>log_gamma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double hopi::math::Ops::log_gamma </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the logarithm of the gamma function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the function's inputs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the logarithm of the gamma function of x </dd></dl>

</div>
</div>
<a id="a173ec1c26a57825cd6e62e78454a6a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173ec1c26a57825cd6e62e78454a6a34">&#9670;&nbsp;</a></span>multiplication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor hopi::math::Ops::multiplication </td>
          <td>(</td>
          <td class="paramtype">const torch::Tensor &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const torch::Tensor &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; int &gt;&#160;</td>
          <td class="paramname"><em>ml</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the element-wise multiplication of "x1" by "x2" after properly expanding "x2" such that its shape matches the shape of "x1".</p>
<p>Details: This operator performs tensor expansions so that the sizes of of the dimensions of "x2" matches the size of the dimensions of "x1". Then, it re-arranges the dimensions of "x2" by performing a permutation of its dimensions so that the shape of "x2" matches the shape of "x1". Note that the permutation uses the matching list "ml" to know which dimensions of "x2" should be matched to which dimensions of "x1".</p>
<p>More details can be found in the paper named: "The compelling free energy: A novel perspective on active inference".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>the first tensor </td></tr>
    <tr><td class="paramname">x2</td><td>the second tensor </td></tr>
    <tr><td class="paramname">ml</td><td>the matching list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the element-wise multiplication of "x1" by "x2" after properly expanding "x2" </dd></dl>

</div>
</div>
<a id="ae5855f2d59338b8b84581cff7be312ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5855f2d59338b8b84581cff7be312ac">&#9670;&nbsp;</a></span>one_hot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor hopi::math::Ops::one_hot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a one-hot vector </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>the vector's size </td></tr>
    <tr><td class="paramname">index</td><td>the index at which a one should be placed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the one-hot vector </dd></dl>

</div>
</div>
<a id="ad3deee995268f1826fb72963a7a57369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3deee995268f1826fb72963a7a57369">&#9670;&nbsp;</a></span>outer_tensor_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor hopi::math::Ops::outer_tensor_product </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; torch::Tensor * &gt;&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the outer tensor product between the tensors sent as parameters. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ts</td><td>the input tensors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the outer tensor product </dd></dl>

</div>
</div>
<a id="ad6d2f9cd2ca79e693c691e610d99be4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d2f9cd2ca79e693c691e610d99be4e">&#9670;&nbsp;</a></span>randomInt() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hopi::math::Ops::randomInt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a random integer according to a discrete distribution </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>the distribution's weights </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the random integer </dd></dl>

</div>
</div>
<a id="a0923f77839f6fadb4d7895a34d273de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0923f77839f6fadb4d7895a34d273de7">&#9670;&nbsp;</a></span>randomInt() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hopi::math::Ops::randomInt </td>
          <td>(</td>
          <td class="paramtype">const torch::Tensor &amp;&#160;</td>
          <td class="paramname"><em>weights</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a random integer according to a discrete distribution </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weights</td><td>the distribution's weights </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the random integer </dd></dl>

</div>
</div>
<a id="a54ded19f4540bc43d595c650c99f416b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ded19f4540bc43d595c650c99f416b">&#9670;&nbsp;</a></span>randomInt() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hopi::math::Ops::randomInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a random integer uniformly between 0 and max </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>the largest integer that can be generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the random integer </dd></dl>

</div>
</div>
<a id="a800d365ad2c44f7d382e0eaac193a340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800d365ad2c44f7d382e0eaac193a340">&#9670;&nbsp;</a></span>uniform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor hopi::math::Ops::uniform </td>
          <td>(</td>
          <td class="paramtype">const torch::IntArrayRef &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a tensor in which the elements are equal to one over the number of elements in the dimension "dim", e.g., uniform({2,3}, 0) will return the following matrix: | 0.5 0.5 0.5 | | 0.5 0.5 0.5 | where each element equals 0.5 = 1 / number of rows. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizes</td><td>the sizes of each dimension of the tensor being created </td></tr>
    <tr><td class="paramname">dim</td><td>the dimension along which the tensor must store uniform distributions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created tensor </dd></dl>

</div>
</div>
<a id="a1a085233112e587f7bb3e3d847480d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a085233112e587f7bb3e3d847480d8e">&#9670;&nbsp;</a></span>unsqueeze()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hopi::math::Ops::unsqueeze </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; torch::Tensor * &gt;&#160;</td>
          <td class="paramname"><em>tensors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsqueeze oll tensors sent as parameters n times. Note that the dimension is added before all other dimensions, i.e., at the end. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the number of times each tensor must be unsqueezed </td></tr>
    <tr><td class="paramname">tensors</td><td>the tensors to be unsqueezed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>libs/hopi/srcs/math/<a class="el" href="Ops_8h_source.html">Ops.h</a></li>
<li>libs/hopi/srcs/math/Ops.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
