<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# 'tf_device' Dialect

The TensorFlow Device dialect.

This dialect contains operations to describe/launch computations on devices.
These operations do not map 1-1 to TensorFlow ops and requires a lowering
pass later to transform them into Compile/Run op pairs, like XlaCompile and
XlaRun.

[TOC]

## Operation definition

### `tf_device.cluster_func` (::mlir::tf_device::ClusterFuncOp)


The `tf_device.cluster_func` launches a function containing the body of a
cluster.
  

This op is used for outlining a cluster.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`func` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operands` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`results` | any type

### `tf_device.cluster` (::mlir::tf_device::ClusterOp)


The `tf_device.cluster` op wraps containing operations in a region.
  

This op can be used to group operations, and captures all needed live-in values.

#### Results:

| Result | Description |
| :----: | ----------- |
`results` | any type

### `tf_device.launch_func` (::mlir::tf_device::LaunchFuncOp)


    The `tf_device.launch_func` launches a function on target device.
  


#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`device` | ::mlir::StringAttr | string attribute
`func` | ::mlir::FlatSymbolRefAttr | flat symbol reference attribute

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`operands` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`results` | any type

### `tf_device.launch` (::mlir::tf_device::LaunchOp)


The `tf_device.launch` op launches containing operations on target device.
  

This op captures all needed live-in values.

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`device` | ::mlir::StringAttr | string attribute

#### Results:

| Result | Description |
| :----: | ----------- |
`results` | any type

### `tf_device.parallel_execute` (::mlir::tf_device::ParallelExecuteOp)



ParallelExecute op concurrently executes variadic number of regions. Regions
must represent separate sets of instructions to execute concurrently. In
order to represent concurrently executed regions with dependencies, multiple
ParallelExecute ops can be used instead. As so, regions within
ParallelExecute op must not have control/data dependencies.

While explicit dependencies between regions are disallowed, ParallelExecute
op does not prevent implicit communication between regions (e.g.
communication via send/recvs). In this case, users of ParallelExecute op
must provide correct control dependencies between regions to guarantee
correctness. Regions in ParallelExecute may include Resource ops.

In the case where different regions include ops access the same resource,
the users of the ParallelExecute op must provide mechanism (via send/recvs
or via control dependencies) to guarantee correct ordering. Sequential
ordering of ops within a region is guaranteed. Also, sequential ordering of
ops before/after ParallelExecute ops are guaranteed. That is, execution of
regions inside ParallelExecute op is blocked until all inputs to all regions
are materialized and ops following ParallelExecute op are blocked until all
regions are executed.

#### Results:

| Result | Description |
| :----: | ----------- |
`execute_outputs` | any type

### `tf_device.replicate` (::mlir::tf_device::ReplicateOp)

Wraps an N-way replicated computation.

The region held by this operation represents a computation that is replicated
across multiple devices. The number of replications is based on the `n`
attribute. Explicit devices can be populated in the `devices` attribute, and it
must be a mapping of device alias to list of explicit or aliased device names
from the outer scope. The device name map specifies devices on which replicated
ops inside tf_device.replicate will be executed.

A tf_device.parallel_execute inside the tf_device.replicate op region may be
used to represent computations across a larger set of devices. In that case, the
device alias can be used to specify device assignment and replication of each
concurrent execution (i.e. region) defined by tf_device.parallel_execute op.
The size of each value list in the device name map must match `n`. Within a
replica, the execution semantics follow standard sequential behavior. Ops in the
tf_device.replicate wrapped with a tf_device.launch will have its device set to
the associated replicated device from `devices` if the tf_device.launch refers
to an aliased device name. Otherwise the device already set in tf_device.launch
is used instead.

Operands are replicated inputs and packed inputs.

replicated_inputs: each group of `n` inputs corresponds to an input for a single
individual replica and is mapped to a single region argument. Inside one group
the operands are matching in order the `devices` attribute. Each replicated
input must have compatible shapes and types.
packed_inputs: each input corresponds to an input broadcasted across all
replicas and is mapped to a single region argument.

Operands not replicated can be implicitly captured by ops in the region. Results
are replicated each from the regions terminator.

For example:
```
%0 = "tf.opA"() : () -> tensor<i32>
%1 = "tf.opB"() : () -> tensor<i32>
%2 = "tf.opC"() : () -> tensor<f32>
%3 = "tf.opD"() : () -> tensor<f32>
%4 = "tf.opE"() : () -> tensor<!tf.resource>
%5 = "tf.opF"() : () -> tensor<!tf.resource>
%6 = "tf.opG"() : () -> tensor<!tf.string>
%7 = "tf.opH"() : () -> tensor<!tf.string>
%8 = "tf.opI"() : () -> tensor<!tf.variant>
%9 = "tf.opJ"() : () -> tensor<i1>
%output:8 = tf_device.replicate([%0, %1] as %input_0: tensor<i32>,
                                [%2, %3] as %input_1: tensor<f32>,
                                [%4, %5] as %input_2: tensor<!tf.resource>,
                                [%6, %7] as %input_3: tensor<!tf.string>,
                                %8 as %input_4: tensor<!tf.variant>)
                {n = 2 : i32,
                 devices = {DEVICE_ALIAS_0 = ["/DEVICE:0", "/DEVICE:1"],
                            DEVICE_ALIAS_1 = ["/DEVICE:2", "/DEVICE:3"]}} {
  // Inside the region, %0, %2, %4, and %6 corresponds to
  // "/DEVICE:0"/"/DEVICE:2" and %1, %3, %5, and %7 corresponds to
  // "/DEVICE:1"/"/DEVICE:3", depending on which device alias is used.
  %k = "tf_device.launch"() ( {
    %9 = "tf.opK"(%input_0, %input_4, %9) :
      (tensor<i32>, tensor<!tf.variant>, tensor<i1>) -> tensor<i32>
    tf_device.return %9 : tensor<i32>
  }) {device = "DEVICE_ALIAS_0"} : () -> tensor<i32>
  %l = "tf_device.launch"() ( {
    %10 = "tf.opL"(%input_1, %input_4, %9) :
      (tensor<f32>, tensor<!tf.variant>, tensor<i1>) -> tensor<f32>
    tf_device.return %10 : tensor<f32>
  }) {device = "DEVICE_ALIAS_1"} : () -> tensor<f32>
  %m = "tf_device.launch"() ( {
    %11 = "tf.opM"(%input_2, %input_4, %9) :
      (tensor<!tf.resource>, tensor<!tf.variant>, tensor<i1>)
        -> tensor<!tf.resource>
    tf_device.return %11 : tensor<!tf.resource>
  }) {device = "/DEVICE:4"} : () -> tensor<f32>
  %n = "tf.opN"(%input_3, %input_4, %9) :
    (tensor<!tf.string>, tensor<!tf.variant>, tensor<i1>)
      -> tensor<!tf.string>
  tf_device.return %k, %l, %m, %n :
    tensor<i32>, tensor<f32>, tensor<!tf.resource>, tensor<!tf.string>
}
// %output#0 corresponds to %k returned from "/DEVICE:0"
// %output#1 corresponds to %k returned from "/DEVICE:1"
// %output#2 corresponds to %l returned from "/DEVICE:2"
// %output#3 corresponds to %l returned from "/DEVICE:3"
// %output#4, %output#5 corresponds to %m and will be returned from "/DEVICE:4"
// %output#6, %output#7 corresponds to %n and will have no device set
```

#### Attributes:

| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
`operand_segment_sizes` | ::mlir::DenseIntElementsAttr | 32-bit signless integer elements attribute
`n` | ::mlir::IntegerAttr | 32-bit signless integer attribute whose minimum value is 2
`devices` | ::mlir::DictionaryAttr | dictionary of named attribute values

#### Operands:

| Operand | Description |
| :-----: | ----------- |
`replicated_inputs` | any type
`packed_inputs` | any type

#### Results:

| Result | Description |
| :----: | ----------- |
`replicated_outputs` | any type

### `tf_device.return` (::mlir::tf_device::ReturnOp)


The `tf_device.return` operation terminates and returns values from a
`tf_device` dialect operation.
  


Syntax:

```
operation ::= `tf_device.return` attr-dict ($results^ `:` type($results))?
```


#### Operands:

| Operand | Description |
| :-----: | ----------- |
`results` | any type

